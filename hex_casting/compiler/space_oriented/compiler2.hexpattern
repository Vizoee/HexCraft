/*


idea:
    everything is on stack and some things take from stack
    what about " - insides shouldnt be processed - requires processing overide
        can apply to comments
    2 events
        on insert on stack
        on processing
        on taking from stack
    variable/value
        variable - shouldnt happen? remove it from stack?
        //     = get variable and set it
        +,-,/,*,^,% - remove it and remove variable/value - returns value
        =,( - just put variable on stack
        function - set function name

    function
        put block on stack

    end
        remove until finds block (function/if/while/for/switch)

variable, sign and function share method(index in list) to get value
    variable - returns value
    sign(+,-,*,/) - gets value of argument 1 and 2, runs function and then returns value
    function - compiles and runs conde and returns value 
        (every function returns some value or null)

should things predict future?
    if yes:
        requires more careful approach - each element must know what will happen next
        simplifies some things - comments, math(if we don't implement ++/--variable), function
    if partially:
        most freedom
        most likely to introduce bugs
    if no:
        more robust?
        will require processing function stack - which is arguably the same as predicting future
        simplifies implementation of most things

math requires rebalancing of tree
anything other than math operators +,-,*,/,( should process math


processing function stack
    can be used to process next commands
    should it be running before or after command

ravenmind
    [0]variable count
    [1]identifier list
        [0]type
        [1]get function
        [2]var-pos
        [2]func-code(unparsed?)
    [2]variable_count

get_value function
    // stack: obj

identifier
    put on stack:
    [
        [0]type:identifier
        [1]get_value: return value
        [2]value: name
    ]

=
    get identifier from stack
    change it into variable
        change type to variable
        allocate it and set pos

    put on stack
    [
        [0]type:setter
        [1]get_value:get val_2 and set val_1 (and returns set value)
        [2]val_1:identifier or stack_item
        [3]val_2:null
    ]

+
    get identifier or equasion from stack

    put on stack
    [
        [0]type:expression
        [1]get_value:(rebalance tree) get val_2 and set val_1 calculate and return result
        [2]val_1:identifier or stack_item
        [3]val_2:null
    ]

number
    put on stack
    [
        [0]type:value
        [1]get_value:return value
        [2]value
    ]

*/

#def(dict_read)(#git(/hex_casting/programs/dictionary/dictionary_read.hexpattern))

#def(raven_stack)(0)
#def(raven_ident)(1)
#def(raven_var_count)(2)

#def(stack_obj_type)(0)
#def(stack_obj_eval)(1)
#def(stack_obj_val1)(2)
#def(stack_obj_val2)(3)

#def(ident_obj_type)(@str(identifier))

// #def(malloc)(
//     // stack: value
//     Muninn's Reflection
//     $raven_var_count
//     Selection Distillation

//     Muninn's Reflection
//     Prospector's Gambit
//     Numerical Reflection: 1
//     Additive Distillation
//     $raven_var_count
//     Jester's Gambit
//     Surgeon's Exaltation

//     Flock's Reflection
//     Subtractive Distillation
//     Numerical Reflection: 2
//     Additive Distillation
//     Fisherman's Gambit
// )

// #def(get_stack_last)(
//     Muninn's Reflection
//     $raven_stack
//     Selection Distillation
//     Numerical Reflection: 0
//     Selection Distillation
// )

#def(pop_stack_last)(
    Muninn's Reflection
    Speaker's Decomposition
    Speaker's Decomposition
    Rotation Gambit II
    Speaker's Distillation
    Huginn's Gambit
    // stack: obj
)

// #def(remove_stack_last)(
//     Muninn's Reflection
//     Speaker's Decomposition
//     Speaker's Decomposition
//     Bookkeeper's Gambit: v
//     Speaker's Distillation
//     Huginn's Gambit
// )

#def(push_stack)(
    // stack: object
    Muninn's Reflection
    Speaker's Decomposition
    Rotation Gambit
    Speaker's Distillation
    Speaker's Distillation
    Huginn's Gambit
)

#def(value_obj)(
    // stack: value
    {@str(value)}>>
    {
        // stack: obj
        $stack_obj_val1
        Selection Distillation
    }
    Rotation Gambit
    Numerical Reflection: 3
    Flock's Gambit
)

#def(ident_obj)(
    // stack: name
    {$ident_obj_type}>>
    {
        // stack: obj
        $stack_obj_val1
        Selection Distillation
    }
    Rotation Gambit
    Numerical Reflection: 3
    Flock's Gambit
)

#def(setter_obj)(
    // stack: value
    Bookkeeper's Gambit: v
    {@str(setter)}>>

    {

    }

    $pop_stack_last
    Gemini Decomposition
    $stack_obj_type
    Selection Distillation
    {$ident_obj_type}>>
    Equality Distillation
    {}
    { // Error
        {@str(Error while parsing '='. Expected identifier but got )}>>
        Jester's Gambit
        $stack_obj_type
        Selection Distillation
        Additive Distillation
        Hermes' Gambit
    }
    Augur's Exaltation
    Hermes' Gambit

    Nullary Reflection

    Numerical Reflection: 4
    Flock's Gambit
)





{
    Flock's Disintegration
    // stack: list, index
    // check if string
    Dioscuri Gambit
    Selection Distillation
    Gemini Decomposition
    Classifier's Purification
    Scrivener's Purification
    {@str(moreiotas:string)}>>
    Equality Distillation
    {}
    {
        Bookkeeper's Gambit: v
        Numerical Reflection: 1
        Additive Distillation
        Numerical Reflection: 2
        Flock's Gambit
        Castor's Gambit
        Atalanta's Gambit
    }
    Augur's Exaltation
    Hermes' Gambit
    
    // check if not empty
    Gemini Decomposition
    Augur's Purification
    {
        Bookkeeper's Gambit: v
        Numerical Reflection: 1
        Additive Distillation
        Numerical Reflection: 2
        Flock's Gambit
        Castor's Gambit
        Atalanta's Gambit
    }
    {}
    Augur's Exaltation
    Hermes' Gambit

    // stack: list, index, string
    Gemini Decomposition
    Input Purification
    Nullary Reflection
    Equality Distillation
    {
        Input Purification
        $value_obj
        $push_stack

        Numerical Reflection: 2
        Flock's Gambit
        Castor's Gambit
    }
    {}
    Augur's Exaltation
    Hermes' Gambit
    

    {
        [
            @str(=)
        ]
        [
            $setter_obj
            $push_stack
        ]
    }
    Prospector's Gambit
    $dict_read

    Gemini Decomposition
    Augur's Purification
    {
        Hermes' Gambit
        Numerical Reflection: 2
        Flock's Gambit
        Castor's Gambit
    }
    {
        Bookkeeper's Gambit: v
    }
    Augur's Exaltation
    Hermes' Gambit
    

    // $ident_obj
    $push_stack
    
    // end stack: list, index
    Numerical Reflection: 2
    Flock's Gambit
    Castor's Gambit
}
